{"name":"Maki","tagline":":bento: Framework for hand-rolling web applications.  Originally created at Triangle Startup EDU 2013, and later used to build @coursefork and many other projects.","body":"Maki\r\n==============\r\n[![Build Status](https://travis-ci.org/martindale/maki.svg)](https://travis-ci.org/martindale/maki)\r\n[![Coverage Status](https://coveralls.io/repos/martindale/maki/badge.png?branch=master)](https://coveralls.io/r/martindale/maki?branch=master)\r\n\r\nMaki is a framework for hand-rolling web applications in a way that makes sense to a human.\r\n\r\n- **REST API built-in.**  All URIs are semantic and indempotent, automatically.\r\n- **Client-Responsiveness.**  Don't rely on user-agents or referers, but instead respond to what the client supports.  Make a request that only accepts JSON?  Get JSON back.  Accept HTML?  Get HTML back.\r\n- **Javascript _optional_.**  If the client doesn't have Javascript enabled, applications built with Maki will continue to work using pure HTML.  When Javascript _is_ available, a performant and well-designed client-side application takes over to eliminate full-page loads.  See also [Modules](#modules).\r\n\r\n## Quick Start\r\nYou'll need [node.js](http://nodejs.org) to build a Maki application.   Additionally, [MongoDB](http://mongodb.org) and [Redis](http://redis.org) are the default storage and messaging engines, so you will need to install and configure them to use the defaults, or override them if you'd like to use something different.\r\n\r\n1. Install Maki: `npm install martindale/maki`\r\n2. Create your app, perhaps in `yourapp.js`:\r\n  ```javascript\r\n  var myApp = new require('maki');\r\n  \r\n  myApp.define('Widget', {\r\n    attributes: {\r\n      name: String\r\n    }\r\n  });\r\n  \r\n  myApp.start();\r\n  ```\r\n3. Start your app: `node yourapp.js` – by default, accessible at [http://localhost:9200](http://localhost:9200)\r\n\r\n### Configuration\r\n\r\nMaki-built apps do not require any special configuration.  However, it is intended to be a platform for customization – it will look in your project's folder for customizations (such as a change to the HTTP port) based on the pattern exposed by [its Default Directory Structure](#default-directory-structure).\r\n\r\nFor example, add this file to `./config/index.js` to change the HTTP port:\r\n```javascript\r\nmodule.exports = { services: { http: { port: 8080 } } };\r\n```\r\n\r\n...or this file to `./app/views/index.jade` to change what the index page looks like:\r\n```jade\r\nextends layouts/default\r\n\r\nblock content\r\n  h1 Hello, world!\r\n```\r\n\r\nMaki is zero-configuration by default, but will use your changes where available as an extension to its own internal, default behaviors.  See below for further documentation on the options and default behaviors.\r\n\r\n## Documentation\r\nMaki exposes an extremely simple interface to a powerful set of features.  These features are easy to understand, as they stem from a basic set of principles and philosophies.  We'll start with some simple definitions.\r\n\r\n### Definitions\r\nIn general, we'll be using the proper noun form of these definitions when referring to them explicitly.\r\n\r\n- **Application:** the executable process that binds Resources and their associated Models, Controllers, and Views into a deliverable Service.\r\n- **Resource:** the abstract concept of an interactive object.  For example, a \"user\" of a website is a Resource, and can be interacted with; created (registered), listed (page displaying a list of users), and viewed (profile page).  Resources generally expose one or more identifiers, or Uniform Resource Identifiers (URI).\r\n- **Module:** a collection of **renderables** (html, lexers, etc.) and **their associated styling**.  For example, in an HTML context, a **Module** consists of HTML, Javascript, and associated CSS for styling.\r\n- **Model:** the abstract class that exposes a Resource's Schema and associated validators, methods, and statics.\r\n- **Controller:** the code associated with specific interactions on a Resource and the behavior of the Application.\r\n- **View:** logic and template for displaying a specific Resource.  This generally contains logic and is dependent on context.  A View MAY compose several Modules.\r\n- **Service:** the offering of your app / website / api via various protocols (HTTP, WebSockets, gopher, etc.)\r\n\r\n## Resource-Driven Development (RDD)\r\nGenerally, programming applications involves writing logic around a series of Resources to control their behavior and deliver an experience with the application's \"Scope\".  Maki aims to _start_ with that mental model of your application's \"Scope\", allow you to **hand-roll** (get it?) extensions (read: add business logic) to that mental model, and then deliver that model as a Service.\r\n\r\n**Example Maki Application**  \r\nAll URIs are automatically derived from the the Resource definition.\r\n```javascript\r\nvar config = require('./config');\r\n\r\nvar Maki = require('maki');\r\nvar maki = new Maki( config );\r\n\r\nmaki.define('Person', {\r\n  attributes: {\r\n    name: { type: String , max: 80 },\r\n    slug: { type: String , max: 80 , id: true }\r\n  }\r\n});\r\n\r\nmaki.start();\r\n```\r\nThat's it.  That's all you need.  A `GET` request to `/people` will now provide a list of people:\r\n\r\n```bash\r\n> curl http://localhost:9200/people\r\n[{\"slug\": \"martindale\", \"name\": \"martindale\"}]\r\n```\r\nRequesting an HTML version of that Resource will give you exactly that:\r\n```bash\r\n> curl -H \"Accept: text/html\" http://localhost:9200/people\r\n<!DOCTYPE html>\r\n<html>\r\n<!-- rendered version of the resource snipped -->\r\n...\r\n```\r\nSimilarly, you can subscribe to updates to that same Resource by switching to the `ws://` protocol:\r\n```javascript\r\nvar socket = new WebSocket( 'ws://localhost:9200/people' );\r\nsocket.onmessage = function(msg) {\r\n  // receive an event here\r\n  console.log('received event, method: ' + JSON.parse(msg).method );\r\n}\r\n```\r\nThis newly-opened websocket will, by default, be subscribed to all updates to the `people` Resource, including new additions to the underlying collection, or modifications to the elements contained therein.\r\n\r\nFor convenience, Maki exposes some basic methods to the client. Here's the same request using the convenience methods:\r\n```javascript\r\nmaki.sockets.subscribe('/people');\r\n```\r\nYou can subscribe to multiple resources on a single socket, as follows:\r\n```javascript\r\nmaki.sockets.subscribe('/people');\r\nmaki.sockets.subscribe('/examples');\r\n```\r\nMaki's events utilize [JSON-RPC 2.0](http://www.jsonrpc.org/specification), allowing for a clearly defined interaction model with error handling and simple concurrency.\r\n\r\nUpdates from the server are additionally encapsulated using [RFC 5789, PATCH Method for HTTP](http://tools.ietf.org/html/rfc5789).  This allows for complex, but _atomic_ updates of specific resources that might be cached locally (server -> client) or updated remotely (client -> server).  For further explanation HTTP PATCH, see [Mark Nottingham's explanation of the problem](https://www.mnot.net/blog/2012/09/05/patch).\r\n\r\n#### Reconnection\r\nMaki's sockets are resilient to latency, network connectivity issues, and multiple-tenant environments, for up to 24 hours (configurable).  The server will intelligently clean up idle sockets, and clients will intelligently reconnect using a pre-configured back-off strategy.\r\n\r\n#### Validators\r\nEvery attribute on a Resource can have custom validators:\r\n```javascript\r\nvar Person = maki.define('Person', {\r\n  attributes: {\r\n    username: { type: String , max: 80 , required: true , slug: true }\r\n  }\r\n});\r\n\r\nPerson.path('username', function(value) {\r\n  if (value.length < 5) return false;\r\n  \r\n  return true;\r\n}, 'Invalid username.  Must be > 5 characters.');\r\n```\r\n\r\nValidators can also be defined as functions on attributes themselves by supplying a `validator`:\r\n```javascript\r\nmaki.define('Person', {\r\n  attributes: {\r\n    username: { type: String , max: 80 , required: true , slug: true , validator: function(value) {\r\n      if (value.length < 5) return false;\r\n      \r\n      return true;\r\n    } }\r\n  }\r\n});\r\n```\r\n\r\n\r\n### Methods\r\nAll Maki resources expose exactly five (5) methods:\r\n\r\n- **query** to select a list of documents,\r\n- **get** to get a single instance of a document by its identifier (ID),\r\n- **create** to create a new instance of a document,\r\n- **update** to change properties of a document, and\r\n- **destroy** to remove a document.\r\n\r\n### Events\r\nMaki exposes events at the Resource level (as emitted by the above Methods):\r\n\r\n```javascript\r\nmaki.resources.Person.on('create', function( person ) {\r\n  console.log('new Person', person);\r\n});\r\n```\r\n\r\n...as well as on the Storage level (as `pre` or `post` middleware):\r\n\r\n```javascript\r\nmaki.resources.Person.post('save', function(done) {\r\n  var person = this;\r\n  \r\n  console.log('just saved a Person:' , person);\r\n  \r\n  done();\r\n});\r\n```\r\n\r\n### Dependency Injection\r\nOften, a single Resource we need other Resources to be contextualized into a View.  For example, viewing a \"Person\" (viewing a profile page) may require collecting a list of \"Projects\" (another resource, a subcollection of documents _owned_ by a Person), but the JSON representation of that View is not an accurate representation of the Resource.  For this case, _only_ the HTML context of the View will collect the necessary dependencies.\r\n\r\n**person.jade**\r\n```jade\r\nextends layouts/default\r\n\r\nblock content\r\n\r\n  h1 #{person.name}\r\n  \r\n  h2 Projects\r\n  ul\r\n    each project in projects\r\n      include partials/project\r\n  \r\n```\r\n\r\nThis will allow Maki to collect the \"projects\" Resource as a subcollection of the Person Resource, or more specifically, only within this View.  The JSON View will _not_ collect Projects, and subsequently spare [precious] server time.\r\n\r\n### PubSub\r\nWebSockets exposed by Maki are, by default, subscribed to the Resource exposed by the path you're connecting to.  For example, `ws://localhost:9200/people` will subscribe to the People resource, as defined by Maki.  This may not be ideal for subscribing to multiple (or _many_ resources), so Maki allows for multi-plexing on single websocket connections:\r\n\r\n```javascript\r\nmaki.sockets.subscribe('/examples');\r\n```\r\n\r\nIn pure Javascript (without Maki):\r\n```javascript\r\nvar ws = new WebSocket('ws://localhost:9200/people');\r\nws.on('open', function() {\r\n  \r\n  var JSONRPCEvent = {\r\n    jsonrpc: '2.0',\r\n    method: 'subscribe',\r\n    data: {\r\n      channel: '/examples'\r\n    }\r\n  };\r\n  \r\n  ws.send( JSON.stringify( JSONRPCEvent ) );\r\n});\r\n```\r\n\r\nIn both of the above examples, the currently open WebSocket will now receive events for both the `/people` and the `/examples` paths (or rather, the Resources _exposed_ by those paths).\r\n\r\n## Architecture\r\nMaki's architecture is Resource-centric.  All aspects of the datastore, its query pipeline, the business logic, and view layer are derived from the definition of the Resources your application exposes.\r\n\r\nTODO: IMAGE HERE\r\n\r\nTODO: explanation here.\r\n\r\n### RPC Methods\r\n- `ping` should be responded to with a \"pong\" result.\r\n- `patch` will provide an array of operations to execute on a resource.\r\n- `subscribe`\r\n- `unsubscribe`\r\n\r\n## Default Directory Structure\r\nMaki is meant to be understood without context or documentation, and as such the directory structure [and the code itself, for that matter] _should_ be fairly self-explanatory.  Nevertheless, here's an explicit declaration for each of the default folders and their intended use.\r\n```bash\r\n.\r\n├── app             # contains the traditional MVC \"app\"\r\n│   ├── controllers # application-specific logic\r\n│   ├── models      # models (schemas, their validators, methods, and statics)\r\n│   └── views       # composable elements for rendering HTML, JSON, or XML\r\n├── config          # configuration files (generally overridden by environment variables)\r\n├── data            # data files for use in various places.\r\n├── lib             # various classes / prototypes\r\n├── private         # resources not exposed to the client (LESS, etc.).  This is a 1:1 map of the public folder\r\n│   └── css         # contains the LESS files used to generate the **public** CSS files (currently, autogenerated using asset-rack)\r\n├── public          # resources exposed to the client (images, CSS, etc)\r\n│   ├── css         # CSS\r\n│   ├── fonts       # Fonts (.woff, etc.)     \r\n│   ├── img         # Images   \r\n│   └── js          # JavaScript  \r\n└── tests           # Tests.  Write them.\r\n```\r\n\r\n### NPM\r\nWe use NPM for package management, exclusively.  You will see in the above folder that `node_modules` is not present; that's because you should consider it ephemeral and **never touch it**.  Let NPM do what it does best: manage packages.\r\n\r\n## Recommended Deployment\r\nI use [pm2](https://github.com/unitech/pm2) (`npm install pm2 -g`) to manage node apps in production, and I strongly recommend you do, too.  It's got awesome features like log management, process clustering, and automatic startup scripts.\r\n\r\nFor Maki by itself, `pm2 start maki.js` will produce the following:\r\n```bash\r\n> pm2 start maki.js \r\nPM2 Process launched\r\n┌──────────┬────┬─────────┬───────┬────────┬───────────┬────────┬─────────────┬─────────────┐\r\n│ App name │ id │ mode    │ PID   │ status │ restarted │ uptime │      memory │    watching │\r\n├──────────┼────┼─────────┼───────┼────────┼───────────┼────────┼─────────────┼─────────────┤\r\n│ maki     │ 0  │ cluster │ 93966 │ online │         0 │ 0s     │ 25.652 MB   │ unactivated │\r\n└──────────┴────┴─────────┴───────┴────────┴───────────┴────────┴─────────────┴─────────────┘\r\n Use `pm2 desc[ribe] <id>` to get more details\r\n```\r\n\r\nYou can check on running processes using `pm2 ls`.  For example, on a server with multiple running services:\r\n```bash\r\n> pm2 ls\r\n┌────────────┬────┬─────────┬───────┬────────┬───────────┬────────┬──────────────┬─────────────┐\r\n│ App name   │ id │ mode    │ PID   │ status │ restarted │ uptime │       memory │    watching │\r\n├────────────┼────┼─────────┼───────┼────────┼───────────┼────────┼──────────────┼─────────────┤\r\n│ para       │ 0  │ cluster │ 21140 │ online │         0 │ 14d    │  69.734 MB   │ unactivated │\r\n│ worker     │ 1  │ cluster │ 21142 │ online │         0 │ 14d    │  83.996 MB   │ unactivated │\r\n│ bot        │ 2  │ cluster │ 21223 │ online │         1 │ 14d    │ 115.543 MB   │ unactivated │\r\n│ maki       │ 3  │ cluster │ 21154 │ online │         0 │ 14d    │  92.676 MB   │ unactivated │\r\n│ soundtrack │ 4  │ cluster │ 32655 │ online │         3 │ 18h    │ 324.176 MB   │ unactivated │\r\n└────────────┴────┴─────────┴───────┴────────┴───────────┴────────┴──────────────┴─────────────┘\r\n Use `pm2 desc[ribe] <id>` to get more details\r\n```\r\n\r\nFor production monitoring, see also `pm2 monit`, `vtop` (available via `npm install vtop -g`), and [StrongLoop](http://strongloop.com/).\r\n\r\nUse environment variables for configuration.  See `config/index.js` for a list of configurable values.\r\n\r\n## Spirit\r\nPlease feel free to submit changes to this repo via pull requests!  We're trying to keep this as general and flexible as possible, so anyone can take the project and run with it.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}